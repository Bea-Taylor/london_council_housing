import pandas as pd
import numpy as np
import re

def format_borough(df, borough_col_name='borough'):
    """ Formats the borough column in the dataframe to remove unnecessary words and characters.

    Args:
        df (df): dataframe to be processed.
        borough_col_name (str, optional): borough column. Defaults to 'borough'.

    Returns:
        df: Same dataframe, with borough column updated.
    """

    unique_boroughs = df[borough_col_name].unique()

    replacements = {
    'London Borough of ': '',
    'Royal Borough of ': '',
    '(LA Code)': '',
    'Bromley Custodian Code': 'Bromley',
    'Council': '',
    #'Kingston': 'Kingston upon Thames',
    '&': 'and',
    'Custodian code': 'nan',
    'Out of Borough': 'Haringey',
    'And': 'and'
    }

    formatted_boroughs = {}
    for bor in unique_boroughs:
        if not isinstance(bor, str):
            bor = str(bor)
        new_bor = bor

        if new_bor == 'Kingston':
            new_bor = 'Kingston upon Thames'

        if new_bor == 'Richmond':
            new_bor = 'Richmond upon Thames'

        
        for old, new in replacements.items():
            new_bor = new_bor.replace(old, new)
        new_bor = new_bor.rstrip()
        formatted_boroughs[bor] = new_bor

    df[borough_col_name] = df[borough_col_name].map(formatted_boroughs)

    return df


def __format_dateime(df):
    """Formats the date columns in the dataframe to datetime format.

    Args:
        df (_type_): Dataframe to be processed.

    Returns:
        _type_: Processed dataframe.
    """

    for col in df.columns:
        if re.findall(r'_date', col):
            df[col] = pd.to_datetime(df[col], format='%d/%m/%Y', errors='coerce')

    return df


def format_df(df, drop_cols=True, borough_col_name='borough'):
    """Formats the dataframe by removing unnecessary words and characters from the column names, 
    formats the date columns and the borough column.

    Args:
        df (_type_): Dataframe to be processed.
        drop_cols (bool, optional): Option to drop columns generated by es search. Defaults to True.
        borough_col_name (str, optional): Name of borough column. Defaults to 'borough'.

    Returns:
        _type_: Processed dataframe.
    """

    new_cols = []
    for col in df.columns:
        n = col.replace('_source.', '')
        n = n.replace('application_details.', '')
        n = n.replace('residential_details.', '')
        new_cols.append(n)

    df.columns = new_cols

    df = __format_dateime(df)

    if borough_col_name in df.columns:
        df = format_borough(df, borough_col_name=borough_col_name)

    if drop_cols == True:
        drop_columns = ['_index', '_type', '_id', '_score', '_ignored']
        for col in drop_columns:
            if col in df.columns:
                df.drop(columns=[col], inplace=True)
        #df.drop(columns=['_index', '_type', '_id', '_score', '_ignored'], inplace=True)

    return df



def __match_decisions(df, decision_col_name='decision', status_col_name='status'):
    """ Matches the decision column to the status column in the dataframe.

    Args:
        df (df): dataframe to be processed.
        decision_col_name (str, optional): decision column. Defaults to 'decision'.
        status_col_name (str, optional): status column. Defaults to 'status'.

    Returns:
        df: Same dataframe, with decision column updated using information from the status column.
    """

    expected = ['Approved', 'Refused', 'Withdrawn', 'Superseded', 'Closed']

    for i, row in df.iterrows():
        if row[status_col_name] in expected and row[decision_col_name] not in expected:
            df.at[i, decision_col_name] = row[status_col_name]
    
    return df


def format_decisions(df, decision_col_name='decision', status_col_name='status'):
    """ Formats the decision and status columns in the dataframe to remove unnecessary words and characters.

    Args:
        df (df): dataframe to be processed.
        decision_col_name (str, optional): decision column. Defaults to 'decision'.
        status_col_name (str, optional): status column. Defaults to 'status'.   

    Returns:
        df: Same dataframe, with decision column and status column updated.
    """

    decisions = df[decision_col_name].unique()
    decisions = decisions.astype(str)

    new_d = {}
    for d in decisions:
        n = d.lower()
        n = n.rstrip()
        if re.findall('\Aapprov|\Aaprov|\Aappprov', n):
            n = 'approved'
        if re.findall('\Arefu', n):
            n = 'refused'
        if re.findall('\Awith', n):
            n = 'withdrawn'

        n = n.replace('allowed', 'approved')
        n = n.capitalize()

        new_d[d] = n

    df[decision_col_name] = df[decision_col_name].map(new_d)

    if status_col_name in df.columns:
        df[status_col_name] = df[status_col_name].map(new_d)

    df = __match_decisions(df, decision_col_name, status_col_name)

    return df


def create_decision_outcomes(df, decision_col_name='decision', status_col_name='status', completion_date_col_name='actual_completion_date'):
    """ Creates a new column in the dataframe with the outcome of the decision. Specifically this column records whether each application was 
    permitted or not permitted, by taking into account the decision, status and completion date columns.

    Args:
        df (df): dataframe to be processed.
        decision_col_name (str, optional): decision column. Defaults to 'decision'.
        status_col_name (str, optional): status column. Defaults to 'status'.
        completion_date_col_name (str, optional): completion date column. Defaults to 'actual_completion_date'.

    Returns:
        df: Same dataframe, with a new column 'outcome' added
    """

    df['outcome'] = df[decision_col_name]

    for i, row in df.iterrows():
        if pd.isnull(row[status_col_name]) == False and (pd.isnull(row[decision_col_name]) ==  True or row[decision_col_name] =='None'):
            df.at[i, 'outcome'] = row[status_col_name]

    outcomes = {
        'Approved': 'Permitted',
        'Called in by secretary of state': 'Ongoing',
        'Closed': 'Not Permitted',
        'Comment issued': 'Ongoing',
        'Declined to determine': 'Not Permitted',
        'Not required': 'Permitted',
        'Refused': 'Not Permitted',
        'Split decision': 'Other',
        'Withdrawn': 'Other',
        'Superseded': 'Superseded',
        'Opinion issued': 'Ongoing',
        'Pre-application Advice Case Completed': 'Ongoing',
        'Referred to mayor': 'Ongoing',
        'Commenced': 'Permitted'
    }

    df['outcome'] = df['outcome'].map(outcomes)

    for i, row in df.iterrows():
        if pd.isnull(row[completion_date_col_name]) == False and row['outcome'] != 'Not Permitted': 
            df.at[i, 'outcome'] = 'Permitted'

    return df


def create_decision_outcomes_new(df, outcome_col_name='outcome', decision_col_name='decision', status_col_name='status', completion_date_col_name='actual_completion_date'):
    """ Creates a new column in the dataframe with the outcome of the decision. Specifically this column records whether each application was 
    permitted or not permitted, by taking into account the decision, status and completion date columns.

    Args:
        df (df): dataframe to be processed.
        outcome_col_name (str, optional): outcome column. Defaults to 'outcome'.
        decision_col_name (str, optional): decision column. Defaults to 'decision'.
        status_col_name (str, optional): status column. Defaults to 'status'.
        completion_date_col_name (str, optional): completion date column. Defaults to 'actual_completion_date'.

    Returns:
        df: Same dataframe, with a new column outcome_col_name added
    """

    df[outcome_col_name] = df[decision_col_name]

    # format decision and status columns
    df['d_format'] = df[decision_col_name].replace(np.nan, 'nan')
    df['s_format'] = df[status_col_name].replace(np.nan, 'nan')
    df['d_format'] = df['d_format'].fillna('nan')
    df['s_format'] = df['s_format'].fillna('nan')

    # lower case all strings
    decision_lower = [d.lower() for d in df['d_format']]
    status_lower = [d.lower() for d in df['s_format']]

    df['d_format'] = decision_lower
    df['s_format'] = status_lower

    # define categories
    permitted = ['approved', 'not required', 'commenced', 'allowed', 'granted', 'permitted', 'consent', 'permit']
    ongoing = ['opinion issued', 'comment issued', 'called in by secretary of state', 'pre-application advice case completed', 'referred to mayor']
    superseded = ['superseded', 'superseded by new application']
    not_permitted = ['refused']
    withdrawn = ['withdrawn', 'withdrawn by applicant']

    # assign outcome to each application
    for i, row in df.iterrows():
        if row['d_format'] in superseded or row['s_format'] in superseded:
            df.at[i, outcome_col_name] = 'Superseded'
        elif row['d_format'] in permitted or row['s_format'] in permitted:
            df.at[i, outcome_col_name] = 'Permitted'
        elif pd.isnull(row[completion_date_col_name]) == False: 
            df.at[i, outcome_col_name] = 'Permitted'
        elif row['d_format'] in not_permitted or row['s_format'] in not_permitted:
            df.at[i, outcome_col_name] = 'Not Permitted'
        elif row['d_format'] in ongoing or row['s_format'] in ongoing:
            df.at[i, outcome_col_name] = 'Ongoing'
        elif row['d_format'] in withdrawn or row['s_format'] in withdrawn:
            df.at[i, outcome_col_name] = 'Withdrawn'
        else:
            df.at[i, outcome_col_name] = 'Other'

    # drop temporary columns used for formatting
    df.drop(columns=['d_format', 's_format'], inplace=True)

    return df